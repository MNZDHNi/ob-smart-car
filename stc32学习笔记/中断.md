# 一、STC32G12K128的中断源

|中断类型|具体中断源|中断号|说明|
|---|---|---|---|
|**外部中断**|INT0, INT1, INT2, INT3, INT4|0, 2, 10, 11, 16|由外部引脚电平/边沿触发|
|**定时器中断**|Timer0, Timer1, Timer2, Timer3, Timer4|1, 3, 12, 19, 20|定时器溢出/匹配时触发|
|**串口中断**|UART1, UART2, UART3, UART4|4, 8, 17, 18|数据发送/接收完成时触发|
|**ADC中断**|ADC转换完成|5|ADC转换结束时触发|
|**其他外设中断**|SPI, I2C, PWM, 比较器, LVD等|9, 21, 22, 20, 6|相应外设事件触发|

# 二、中断相关的关键寄存器

## 1. 中断使能寄存器

```c
// 中断允许寄存器IE
sbit EA = IE^7;   // 总中断开关 (1=开启, 0=关闭)
sbit ET2 = IE^5;  // 定时器2中断允许
sbit ES = IE^4;   // 串口1中断允许
sbit ET1 = IE^3;  // 定时器1中断允许
sbit EX1 = IE^2;  // 外部中断1允许
sbit ET0 = IE^1;  // 定时器0中断允许
sbit EX0 = IE^0;  // 外部中断0允许

// 中断允许寄存器IE2
sbit ET4 = IE2^6; // 定时器4中断允许
sbit ET3 = IE2^5; // 定时器3中断允许
sbit ES4 = IE2^4; // 串口4中断允许
sbit ES3 = IE2^3; // 串口3中断允许
sbit ET2 = IE2^2; // 定时器2中断允许（重复）
sbit ESPI = IE2^1; // SPI中断允许
sbit ES2 = IE2^0; // 串口2中断允许
```

## 3.中断优先级寄存器

```c
// 中断优先级寄存器IP
IP = 0x00; // 默认都是最低优先级

// 设置优先级的位：
// PX0H, PX0L - 外部中断0优先级 (H:高位, L:低位)
// PT0H, PT0L - 定时器0优先级
// PX1H, PX1L - 外部中断1优先级
// PT1H, PT1L - 定时器1优先级
// PSH, PSL   - 串口1优先级
// PPCH, PPCL - PCA/ PWM优先级
// PLVDH, PLVDL - 低压检测优先级
// PADCH, PADCL - ADC优先级

// 优先级编码：
// H L | 优先级
// 0 0 | 0级 (最低)
// 0 1 | 1级
// 1 0 | 2级  
// 1 1 | 3级 (最高)
```

## 3.外部中断控制寄存器

```c
// 外部中断触发方式控制
// INT0: TCON寄存器中的IT0, IT1
// INT1~INT4: INTCLKO寄存器中的相应位

sbit IT0 = TCON^0; // INT0触发方式 (0=低电平, 1=边沿)
sbit IT1 = TCON^2; // INT1触发方式

// 外部中断标志位
sbit IE0 = TCON^1; // INT0中断请求标志
sbit IE1 = TCON^3; // INT1中断请求标志
```

# 三、中断服务函数的编写

## 1.中断函数语法

```c
void 函数名() interrupt 中断号 [using 工作寄存器组]
{
    // 中断处理代码
    // 中断标志位清除（如果需要）
}
```

## 2.中断服务函数示例

```c
#include "stc32g.h"

// 定时器0中断服务函数 - 中断号1
void Timer0_ISR() interrupt 1
{
    static unsigned int counter = 0;
    
    counter++;
    if(counter >= 1000)  // 假设1ms定时，这里就是1秒
    {
        counter = 0;
        P20 = ~P20;  // 翻转LED，实现1秒闪烁
    }
    
    // 定时器0需要手动重装初值（如果工作在模式0）
    TL0 = 0x00;      // 设置定时初值低8位
    TH0 = 0xDC;      // 设置定时初值高8位
}

// 外部中断0服务函数 - 中断号0
void INT0_ISR() interrupt 0
{
    // 检测到P3.2引脚的下跳沿（如果IT0=1）
    P21 = ~P21;  // 翻转另一个LED，指示按键按下
    
    // 外部中断标志位IE0在进入中断后会自动清除（边沿触发时）
}

// 串口1中断服务函数 - 中断号4  
void UART1_ISR() interrupt 4
{
    if(RI)  // 如果是接收中断
    {
        RI = 0;  // 必须软件清除接收中断标志
        // 读取接收到的数据：SBUF
        unsigned char received_data = SBUF;
        // 处理数据...
    }
    
    if(TI)  // 如果是发送中断
    {
        TI = 0;  // 必须软件清除发送中断标志
        // 可以在这里准备下一个要发送的数据
    }
}
```

