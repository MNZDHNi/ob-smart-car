# 一、概述

- **精确计时**：产生精确的时间间隔
- **事件计数**：对外部脉冲进行计数
- **波形生成**：产生PWM、方波等信号
- **中断触发**：在特定时间点触发中断

# 二、STC32G12K128的定时器资源

| 定时器        | 位数  | 工作模式  | 特殊功能              |
| ---------- | --- | ----- | ----------------- |
| **Timer0** | 16位 | 模式0-3 | 通用定时器             |
| **Timer1** | 16位 | 模式0-3 | 通用定时器，常用作串口波特率发生器 |
| **Timer2** | 16位 | 自动重装  | 增强型定时器            |
| **Timer3** | 16位 | 自动重装  | 增强型定时器            |
| **Timer4** | 16位 | 自动重装  | 增强型定时器            |

## 二、定时器工作原理

## 1.基本计数原理

定时器的核心是一个**计数器**，它有两种工作方式：

1. **定时器模式**：对**内部系统时钟**进行计数
2. **计数器模式**：对**外部引脚(T0/T1等)** 的脉冲进行计数

## 2.时钟源与分频

| 系统时钟 | 12分频 | 定时器时钟  | 计数器计数    |
| ---- | ---- | ------ | -------- |
| Fsys | 可选   | Ftimer | THx, TLx |

**计算公式**：

- 定时器计数频率 = Fsys / 12
- 定时时间 = (65536 - 初值) × (12 / Fsys)

# 三、定时器工作模式详解

### 1.Timer0/Timer1的工作模式

#### 模式0：16位自动重装载模式（推荐）

```c
// 配置Timer0为模式0
TMOD &= 0xF0;  // 清零Timer0模式位
TMOD |= 0x00;  // 模式0：16位自动重装

TL0 = 0x00;    // 设置定时初值低8位
TH0 = 0xDC;    // 设置定时初值高8位

// 自动重装值存储在RL_TL0和RL_TH0中
RL_TL0 = 0x00;
RL_TH0 = 0xDC;
```

**特点**：

- 16位计数，计数范围0-65535
- 溢出后自动从RL_THx/RL_TLx重装初值
- 无需软件干预，定时精确

#### 模式1：16位定时器/计数器（传统8051模式）

```c
TMOD |= 0x01;  // Timer0模式1
TL0 = 0x00;    // 初值低8位
TH0 = 0xDC;    // 初值高8位
```

**特点**：

- 16位计数，无自动重装
- 溢出后需要软件重新赋初值
- 定时精度受中断响应时间影响

#### 模式2：8位自动重装

```c
TMOD |= 0x02;  // Timer0模式2
TL0 = 0x06;    // 8位计数初值
TH0 = 0x06;    // 自动重装值
```

**特点**：

- 8位计数，范围0-255
- TLx计数，THx存放重装值
- 适合高频定时应用

#### 模式3：双8位定时器（仅Timer0）

```c
TMOD |= 0x03;  // Timer0模式3
TL0 = 0x80;    // TL0作为独立8位定时器
TH0 = 0xC0;    // TH0作为独立8位定时器
```

**特点**：

- Timer0被拆分为两个8位定时器
- TL0使用Timer0资源，TH0借用Timer1资源
- 此时Timer1不能使用模式3

### 2.Timer2/Timer3/Timer4的工作模式

增强型定时器主要工作在**16位自动重装模式**，功能更强大：

```c
// Timer2配置
T2CON = 0x00;   // 定时器模式，不分频
T2H = 0xEC;     // 重装值高8位
T2L = 0x78;     // 重装值低8位

// 使能Timer2中断
IE2 |= 0x04;    // ET2 = 1
```

# 四、定时器相关寄存器详解

## 1. TMOD（定时器模式寄存器）

| 位   | 7      | 6   | 5   | 4   | 3      | 2   | 1   | 0   |
| --- | ------ | --- | --- | --- | ------ | --- | --- | --- |
| 功能  | GATE   | C/T | M1  | M0  | GATE   | C/T | M1  | M0  |
| 定时器 | Timer1 |     |     |     | Timer0 |     |     |     |

- **GATE**：门控位
    
    - 0：仅由TRx控制定时器
    - 1：由TRx和INTx引脚共同控制
    
- **C/T**：定时器/计数器选择
    
    - 0：定时器模式
    - 1：计数器模式
    
- **M1, M0**：工作模式选择
    
    - 00：模式0（16位自动重装）
    - 01：模式1（16位定时器/传统8051模式）
    - 10：模式2（8位自动重装）
    - 11：模式3（双8位定时器）

## 2. TCON（定时器控制寄存器）

| 位   | 7   | 6   | 5   | 4   | 3   | 2   | 1   | 0   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 功能  | TF1 | TR1 | TF0 | TR0 | IE1 | IT1 | IE0 | IT0 |

- **TFx**：定时器x溢出标志
- **TRx**：定时器x运行控制
    
    - 1：启动定时
	- 0：停止定时器

## 3. AUXR（辅助寄存器）

| 位   | 7     | 6     | 5         | 4   | 3   | 2   | 1   | 0   |
| --- | ----- | ----- | --------- | --- | --- | --- | --- | --- |
| 功能  | T0x12 | T1x12 | UART_M0x6 | -   | -   | -   | -   | -   |

- **T0x12, T1x12**：定时器时钟分频选择
    
    - 0：12分频（传统模式）
    - 1：1分频（不分频）

## 4. 中断使能寄存器

```c
// IE寄存器中的定时器中断使能位
sbit EA = IE^7;   // 总中断开关
sbit ET0 = IE^1;  // Timer0中断使能
sbit ET1 = IE^3;  // Timer1中断使能

// IE2寄存器中的定时器中断使能位
sbit ET2 = IE2^2; // Timer2中断使能
```

# 五、定时器配置实战

## 案例1：精确1ms定时（Timer0模式0）

```c
#include "stc32g.h"

// 系统时钟定义
#define FOSC 24000000UL  // 24MHz

void Timer0_Init(void)
{
    // 1. 配置Timer0为模式0（16位自动重装）
    TMOD &= 0xF0;   // 清零Timer0模式位
    TMOD |= 0x00;   // 设置Timer0为模式0
    
    // 2. 设置定时器时钟为1T模式（不分频）
    AUXR |= 0x80;   // T0x12 = 1
    
    // 3. 计算1ms定时初值
    // 计数次数 = 定时时间 × 系统频率
    // 1ms × 24MHz = 24000次
    // 初值 = 65536 - 24000 = 41536 = 0xA240
    TL0 = 0x40;     // 低8位
    TH0 = 0xA2;     // 高8位
    
    // 4. 设置自动重装值
    RL_TL0 = 0x40;
    RL_TH0 = 0xA2;
    
    // 5. 清除溢出标志
    TF0 = 0;
    
    // 6. 开启Timer0中断
    ET0 = 1;
    
    // 7. 启动Timer0
    TR0 = 1;
}

// 全局变量，用于精确计时
volatile unsigned long ms_count = 0;

void Timer0_ISR() interrupt 1
{
    ms_count++;  // 每1ms增加1
    
    // 模式0下自动重装，无需手动重装初值
}

// 精确延时函数
void Delay_ms(unsigned int ms)
{
    unsigned long start_time = ms_count;
    while((ms_count - start_time) < ms);
}

void main()
{
    // GPIO初始化
    P2M0 = 0x00; P2M1 = 0x00;
    P20 = 1;  // LED初始熄灭
    
    // 定时器初始化
    Timer0_Init();
    
    // 开启总中断
    EA = 1;
    
    while(1)
    {
        P20 = 0;        // LED亮
        Delay_ms(500);  // 延时500ms
        P20 = 1;        // LED灭
        Delay_ms(500);  // 延时500ms
    }
}
```

## 案例2：PWM波形生成（Timer2）

```c
#include "stc32g.h"

// PWM相关变量
volatile unsigned int pwm_duty = 500;  // 占空比 0-1000

void Timer2_Init(void)
{
    // 1. 配置Timer2为16位自动重装模式
    T2CON = 0x00;   // 定时器模式，不分频
    
    // 2. 设置PWM周期为1ms（1000Hz）
    // 计数次数 = 24000
    T2H = (65536 - 24000) >> 8;  // 高8位
    T2L = (65536 - 24000) & 0xFF; // 低8位
    
    // 3. 开启Timer2中断
    IE2 |= 0x04;    // ET2 = 1
    
    // 4. 启动Timer2
    T2R = 1;        // 运行Timer2
}

void Timer2_ISR() interrupt 12  // Timer2中断号12
{
    static unsigned int pwm_counter = 0;
    
    pwm_counter++;
    if(pwm_counter >= 1000) 
        pwm_counter = 0;
    
    // 生成PWM波形
    if(pwm_counter < pwm_duty)
        P20 = 0;  // 低电平
    else
        P20 = 1;  // 高电平
}

// 调整PWM占空比
void Set_PWM_Duty(unsigned int duty)
{
    if(duty <= 1000)
        pwm_duty = duty;
}

void main()
{
    P2M0 = 0x01; P2M1 = 0x00;  // P2.0推挽输出
    
    Timer2_Init();
    EA = 1;
    
    while(1)
    {
        // 呼吸灯效果
        for(pwm_duty = 0; pwm_duty < 1000; pwm_duty += 10)
        {
            Delay_ms(20);
        }
        for(pwm_duty = 1000; pwm_duty > 0; pwm_duty -= 10)
        {
            Delay_ms(20);
        }
    }
}
```

## 案例3：外部脉冲计数（Timer1计数器模式）

```c
#include "stc32g.h"

// 脉冲计数变量
volatile unsigned long pulse_count = 0;
volatile unsigned int last_count = 0;

void Timer1_Init(void)
{
    // 1. 配置Timer1为计数器模式，模式0
    TMOD &= 0x0F;   // 清零Timer1模式位
    TMOD |= 0x40;   // C/T=1（计数器模式），模式0
    
    // 2. 设置初值
    TL1 = 0x00;
    TH1 = 0x00;
    RL_TL1 = 0x00;
    RL_TH1 = 0x00;
    
    // 3. 开启Timer1中断
    ET1 = 1;
    
    // 4. 启动Timer1
    TR1 = 1;
}

void Timer1_ISR() interrupt 3
{
    // 每次计数到65535溢出时进入中断
    pulse_count += 65536;  // 加上溢出的计数值
}

// 获取总脉冲数
unsigned long Get_Pulse_Count(void)
{
    unsigned long total;
    unsigned int current_count;
    
    EA = 0;  // 关中断保护
    total = pulse_count;
    current_count = (TH1 << 8) | TL1;  // 读取当前计数值
    EA = 1;
    
    return total + current_count;
}

void main()
{
    // 初始化串口用于显示计数结果
    UART1_Init();
    Timer1_Init();
    EA = 1;
    
    printf("脉冲计数器就绪\r\n");
    
    while(1)
    {
        unsigned long count = Get_Pulse_Count();
        printf("脉冲计数: %lu\r\n", count);
        Delay_ms(1000);
    }
}
```
